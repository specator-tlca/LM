# LM Output Format Description

## Overview

This document describes the structure and contents of output files generated by the Lemaire Delta Detector computational framework for Hecke eigenvalue detection.

## Output Directory Structure

```
LM/
├── results/                                     # Main computation results
│   ├── eigenvalues_p<p>_sigma<σ>_<timestamp>.json    # Single eigenvalue computation
│   ├── scan_<start>_<end>_<timestamp>.csv            # Range scan results
│   ├── lehmer_test_limit<L>_<timestamp>.json         # Lehmer hypothesis test
│   ├── sign_map_<weight>_<level>_<timestamp>.png     # Sign map visualization
│   └── performance_analysis_<timestamp>.csv           # Performance metrics
│
├── cache/                                       # Cached intermediate results
│   ├── chebyshev_nodes_<n>_<timestamp>.npz          # Chebyshev quadrature nodes
│   ├── prime_list_<limit>.pkl                       # Precomputed prime lists
│   └── log_L_values_<hash>.npz                      # Cached log L computations
│
└── logs/                                        # Execution logs (optional)
    ├── detector_<timestamp>.log
    ├── lehmer_analysis_<timestamp>.log
    └── batch_scan_<timestamp>.log
```

## File Formats

### 1. eigenvalues_p<p>_sigma<σ>_<timestamp>.json

JSON file containing single eigenvalue computation results using the Delta Detector method.

**Structure:**
```json
{
  "timestamp": "2025-01-23T15:45:00.123456",
  "parameters": {
    "p0": 29,
    "a": 1,
    "sigma": 1.3,
    "T_factor": 20.0,
    "M": 2,
    "P_limit": 1000000,
    "quad_method": "adaptive",
    "richardson": true
  },
  "computation": {
    "T": 753.5824,
    "J_value": 0.003456,
    "J_normalized": 4.586e-06,
    "lambda_estimate": 52.000123,
    "richardson_correction": 0.000123,
    "integration_error": 1.2e-12
  },
  "validation": {
    "true_lambda": 52,
    "absolute_error": 0.000123,
    "relative_error": 2.37e-06,
    "sign_correct": true,
    "deligne_bound": 57.98,
    "within_bound": true
  },
  "performance": {
    "computation_time": 0.0987,
    "num_integrand_evals": 15432,
    "num_primes_used": 78498,
    "memory_peak_mb": 125.4
  }
}
```

**Key fields:**
- `p0`, `a`: Computing λ(p0^a)
- `sigma`: Real part of s = σ + it in the integral
- `T_factor`: Window size T = T_factor × p0^(aσ)
- `lambda_estimate`: Computed value of λ(p0^a)
- `richardson_correction`: Improvement from Richardson extrapolation
- `deligne_bound`: Theoretical bound |λ(p)| ≤ 2p^((k-1)/2)

### 2. scan_<start>_<end>_<timestamp>.csv

CSV file with eigenvalue computations for a range of primes.

**Format:**
```csv
prime,lambda_true,lambda_estimate,absolute_error,relative_error,sign_correct,computation_time
1009,-140,-139.9987,0.0013,9.29e-06,True,0.0912
1013,324,324.0021,0.0021,6.48e-06,True,0.0923
1019,-2856,-2855.9965,0.0035,1.23e-06,True,0.0935
...
```

**Columns:**
- `prime`: The prime number p
- `lambda_true`: Known value of λ(p) from input data
- `lambda_estimate`: Computed value using Delta Detector
- `absolute_error`: |λ_true - λ_estimate|
- `relative_error`: |error| / |λ_true|
- `sign_correct`: Whether sign(λ_estimate) = sign(λ_true)
- `computation_time`: Time in seconds for this computation

### 3. lehmer_test_limit<L>_<timestamp>.json

JSON file with Lehmer hypothesis test results.

**Structure:**
```json
{
  "timestamp": "2025-01-23T16:00:00.789012",
  "parameters": {
    "limit": 1000000,
    "weight": 12,
    "level": 1,
    "form": "ramanujan_tau",
    "detection_threshold": 1e-6
  },
  "summary": {
    "total_primes_tested": 78498,
    "ramanujan_primes": 0,
    "lehmer_violations": 0,
    "min_abs_lambda": 24,
    "min_lambda_prime": 2,
    "max_computation_time": 0.152,
    "mean_computation_time": 0.098
  },
  "near_violations": [
    {
      "prime": 2411,
      "lambda": -48,
      "abs_lambda": 48,
      "ratio_to_p": 0.0199,
      "computation_time": 0.103
    }
  ],
  "performance": {
    "total_time": 7698.5,
    "primes_per_second": 10.2,
    "memory_usage_mb": 256.7
  }
}
```

**Key fields:**
- `ramanujan_primes`: Count where λ(p) = 0
- `lehmer_violations`: Count where λ(p) = ±1
- `near_violations`: Primes with smallest |λ(p)| values
- `ratio_to_p`: |λ(p)|/p, relevant for Lehmer's conjecture

### 4. sign_map_<weight>_<level>_<timestamp>.png

Visualization of eigenvalue signs across prime ranges.

**Image properties:**
- Format: PNG, 300 DPI
- Size: 3000×2000 pixels
- Content: Scatter plot with primes on x-axis, sign(λ(p)) on y-axis
- Color coding: Blue for positive, red for negative values

### 5. performance_analysis_<timestamp>.csv

Performance metrics for batch computations.

**Format:**
```csv
parameter,value
method,delta_detector
sigma,1.3
T_factor,20.0
M,2
P_limit,1000000
mean_time_per_eigenvalue,0.0987
std_time,0.0123
min_time,0.0823
max_time,0.1523
total_eigenvalues,10000
total_time,987.3
mean_absolute_error,5.67e-04
mean_relative_error,8.92e-07
sign_accuracy,1.0000
memory_peak_mb,512.3
```

## Cache Files

### chebyshev_nodes_<n>_<timestamp>.npz

NumPy compressed archive with Chebyshev quadrature nodes and weights.

**Contents:**
```python
data = np.load('cache/chebyshev_nodes_64_20250123.npz')
nodes = data['nodes']        # shape: (n,)
weights = data['weights']    # shape: (n,)
metadata = data['metadata']  # dict with generation parameters
```

### prime_list_<limit>.pkl

Pickled list of primes up to specified limit.

**Usage:**
```python
import pickle
with open('cache/prime_list_1000000.pkl', 'rb') as f:
    primes = pickle.load(f)  # List of primes up to 10^6
```

### log_L_values_<hash>.npz

Cached log L-function values for reuse across computations.

**Structure:**
```python
data = np.load('cache/log_L_values_a3b7c9.npz')
t_values = data['t']           # shape: (n,)
log_L_values = data['log_L']   # shape: (n,), complex
parameters = data['params']     # dict with σ, form info
```

## Usage Examples

### Loading Single Eigenvalue Result

```python
import json
from pathlib import Path

# Find latest computation for p=29
files = list(Path('results').glob('eigenvalues_p29_*.json'))
if files:
    latest = max(files, key=lambda f: f.stat().st_mtime)
    with open(latest, 'r') as f:
        data = json.load(f)
    
    print(f"λ(29) = {data['computation']['lambda_estimate']:.6f}")
    print(f"Error: {data['validation']['absolute_error']:.2e}")
    print(f"Time: {data['performance']['computation_time']:.3f}s")
```

### Analyzing Scan Results

```python
import pandas as pd

# Load scan results
df = pd.read_csv('results/scan_1000_10000_20250123.csv')

# Summary statistics
print(f"Mean absolute error: {df['absolute_error'].mean():.2e}")
print(f"Sign accuracy: {df['sign_correct'].mean():.1%}")
print(f"Slowest computation: {df['computation_time'].max():.3f}s")

# Find worst estimates
worst = df.nlargest(5, 'relative_error')[['prime', 'relative_error']]
print("Worst relative errors:")
print(worst)
```

### Working with Lehmer Test Results

```python
import json

with open('results/lehmer_test_limit1000000_20250123.json', 'r') as f:
    lehmer_data = json.load(f)

if lehmer_data['summary']['lehmer_violations'] == 0:
    print("No Lehmer violations found!")
    print(f"Tested {lehmer_data['summary']['total_primes_tested']} primes")
    print(f"Smallest |λ(p)|: {lehmer_data['summary']['min_abs_lambda']}")
else:
    print("LEHMER VIOLATION FOUND!")
    # This would be a major mathematical discovery
```

## Data Types and Precision

- **Floating point**: IEEE 754 double precision (64-bit)
- **Complex numbers**: Stored as real and imaginary parts
- **Timestamps**: ISO 8601 format with microsecond precision
- **File naming**: `<timestamp>` format is `YYYYMMDD_HHMMSS`

## Notes

1. **Reproducibility**: All files include complete parameter sets
2. **Cache management**: Cache files can be safely deleted; they will be regenerated
3. **Memory efficiency**: Large computations use memory-mapped arrays when possible
4. **Compression**: NumPy files use compression for space efficiency
5. **Atomicity**: Results are written atomically to prevent corruption

## Error Handling

Failed computations create error files:
- `errors/error_<operation>_<timestamp>.json`
- Contains: parameters, error message, stack trace, partial results

## Storage Requirements

Typical file sizes:
- Single eigenvalue JSON: 2-3 KB
- Scan CSV (1000 primes): ~100 KB
- Lehmer test JSON: 10-50 KB
- Sign map PNG: 500 KB - 2 MB
- Cache files: 1-100 MB depending on parameters
- Total for comprehensive analysis: ~1 GB